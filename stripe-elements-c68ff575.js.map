{"version":3,"file":"stripe-elements-c68ff575.js","sources":["../stripe-elements.js"],"sourcesContent":["import _toArray from '@babel/runtime/helpers/esm/toArray';\nimport _getPrototypeOf from '@babel/runtime/helpers/esm/getPrototypeOf';\nimport _get from '@babel/runtime/helpers/esm/get';\nimport { LitNotify } from '@morbidick/lit-element-notify';\nimport { css, property } from 'lit-element';\nimport { S as StripeBase, s as sharedStyles, b as bound, d as dash } from './shared.js';\nimport 'lit-html/directives/if-defined';\nimport '@babel/runtime/helpers/esm/defineProperty';\nimport '@typed/curry';\nimport 'lit-html';\nimport '@lavadrop/kebab-case';\nimport '@lavadrop/camel-case';\nimport '@pacote/memoize';\n\n/* eslint-disable no-invalid-this */\nfunction wrap(f) {\n  return wrapped => {\n    const {\n      descriptor\n    } = wrapped;\n    const original = descriptor.value;\n    descriptor.value = f(original);\n    return { ...wrapped,\n      descriptor\n    };\n  };\n}\n\nconst stripeMethod = wrap(function (f) {\n  const {\n    name\n  } = f;\n  return async function (...args) {\n    if (!this.stripe) throw new Error(`<${this.constructor.is}>: Stripe must be initialized before calling ${name}.`);\n    return f.call(this, ...args).then(this.handleResponse);\n  };\n});\n\nvar style = css`:host {\n  min-width: var(--stripe-elements-width, 300px);\n  min-height: var(--stripe-elements-height, 50px);\n}\n\n#stripe {\n  box-sizing: border-box;\n  border-radius: var(--stripe-elements-border-radius, 4px);\n  border: var(--stripe-elements-border, 1px solid transparent);\n  box-shadow: var(--stripe-elements-box-shadow, 0 1px 3px 0 #e6ebf1);\n  transition: var(--stripe-elements-transition, box-shadow 150ms ease);\n  min-width: var(--stripe-elements-width, 300px);\n  padding: var(--stripe-elements-element-padding, 8px 12px);\n  background: var(--stripe-elements-element-background, white);\n}\n\n:host([focused]) #stripe {\n  box-shadow: 0 1px 3px 0 #cfd7df;\n}\n\n:host([error]) #stripe {\n  border-color: #fa755a;\n}\n`;\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function () { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function (O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function (F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function (receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function (elements, decorators) { var newElements = []; var finishers = []; var placements = { static: [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function (element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function (element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function (elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function (element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function (elementObjects) { if (elementObjects === undefined) return; return _toArray(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function (elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function (elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function (elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function (obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function (constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function (obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function (other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst allowedStyles = ['color', 'fontFamily', 'fontSize', 'fontStyle', 'fontSmoothing', 'fontVariant', 'iconColor', 'lineHeight', 'letterSpacing', 'textDecoration', 'textShadow', 'textTransform'];\n/**\n * [Stripe.js v3 Card Elements](https://stripe.com/docs/elements), but it's a Web Component!\n * Supports Shadow DOM.\n *\n * ðŸ‘¨â€ðŸŽ¨ [Live Demo](https://bennypowers.dev/stripe-elements/?path=/docs/stripe-elements--enter-a-stripe-publishable-key) ðŸ‘€\n *\n * ### ðŸ§™â€â™‚ï¸ Usage\n * If you prebuilt with Snowpack, load the module from your `web_modules` directory\n *\n * ```html\n * <script type=\"module\" src=\"/web_modules/@power-elements/stripe-elements/stripe-elements.js\"></script>\n * ```\n *\n * Alternatively, load the module from the unpkg CDN\n * ```html\n * <script type=\"module\" src=\"https://unpkg.com/@power-elements/stripe-elements/stripe-elements.js?module\"></script>\n * ```\n *\n * Then you can add the element to your page.\n *\n * ```html\n * <stripe-elements id=\"stripe\"\n *     action=\"/payment\"\n *     publishable-key=\"pk_test_XXXXXXXXXXXXXXXXXXXXXXXX\"\n * ></stripe-elements>\n * ```\n *\n * See the demos for more comprehensive examples.\n *   - Using `<stripe-elements>` with [plain HTML and JavaScript](https://bennypowers.dev/stripe-elements/?path=/docs/framework-examples-html--stripe-elements).\n *   - Using `<stripe-elements>` in a [LitElement](https://bennypowers.dev/stripe-elements/?path=/docs/framework-examples-litelement--stripe-elements).\n *   - Using `<stripe-elements>` in a [Vue Component](https://bennypowers.dev/stripe-elements/?path=/docs/framework-examples-vue--stripe-elements).\n *   - Using `<stripe-elements>` in an [Angular component](https://bennypowers.dev/stripe-elements/?path=/docs/framework-examples-angular--stripe-elements).\n *   - Using `<stripe-elements>` in a [React component](https://bennypowers.dev/stripe-elements/?path=/docs/framework-examples-react--stripe-elements).\n *   - Using `<stripe-elements>` in a [Preact component](https://bennypowers.dev/stripe-elements/?path=/docs/framework-examples-preact--stripe-elements).\n *\n * ## Styling\n *\n * Stripe v3's 'Stripe Elements' are not custom elements, but rather forms\n * hosted by stripe and injected into your page via an iFrame. When we refer to the\n * 'Stripe Element' in this document, we are referring to the hosted Stripe form,\n * not the `<stripe-element>` custom element. But when I mention the 'element', I mean the custom element.\n *\n * When you apply CSS to the custom properties available, they're parsed and sent to Stripe, who should apply them to the Stripe Element they return in the iFrame.\n *\n * - `base` styles are inherited by all other variants.\n * - `complete` styles are applied when the Stripe Element has valid input.\n * - `empty` styles are applied when the Stripe Element has no user input.\n * - `invalid` styles are applied when the Stripe Element has invalid input.\n *\n * There are 11 properties for each state that you can set which will be read into the Stripe Element iFrame:\n *\n * - `color`\n * - `font-family`\n * - `font-size`\n * - `font-smoothing`\n * - `font-variant`\n * - `icon-color`\n * - `line-height`\n * - `letter-spacing`\n * - `text-decoration`\n * - `text-shadow`\n * - `text-transform`\n *\n * @cssprop [--stripe-elements-border-radius] - border radius of the element container. Default `4px`\n * @cssprop [--stripe-elements-border] - border property of the element container. Default `1px solid transparent`\n * @cssprop [--stripe-elements-box-shadow] - box shadow for the element container. Default `0 1px 3px 0 #e6ebf1`\n * @cssprop [--stripe-elements-transition] - transition property for the element container. Default `box-shadow 150ms ease`\n *\n * @cssprop [--stripe-elements-base-color] - `color` property for the element in its base state\n * @cssprop [--stripe-elements-base-font-family] - `font-family` property for the element in its base state\n * @cssprop [--stripe-elements-base-font-size] - `font-size` property for the element in its base state\n * @cssprop [--stripe-elements-base-font-smoothing] - `font-smoothing` property for the element in its base state\n * @cssprop [--stripe-elements-base-font-variant] - `font-variant` property for the element in its base state\n * @cssprop [--stripe-elements-base-icon-color] - `icon-color` property for the element in its base state\n * @cssprop [--stripe-elements-base-line-height] - `line-height` property for the element in its base state\n * @cssprop [--stripe-elements-base-letter-spacing] - `letter-spacing` property for the element in its base state\n * @cssprop [--stripe-elements-base-text-decoration] - `text-decoration` property for the element in its base state\n * @cssprop [--stripe-elements-base-text-shadow] - `text-shadow` property for the element in its base state\n * @cssprop [--stripe-elements-base-text-transform] - `text-transform` property for the element in its base state\n *\n * @cssprop [--stripe-elements-complete-color] - `color` property for the element in its complete state\n * @cssprop [--stripe-elements-complete-font-family] - `font-family` property for the element in its complete state\n * @cssprop [--stripe-elements-complete-font-size] - `font-size` property for the element in its complete state\n * @cssprop [--stripe-elements-complete-font-smoothing] - `font-smoothing` property for the element in its complete state\n * @cssprop [--stripe-elements-complete-font-variant] - `font-variant` property for the element in its complete state\n * @cssprop [--stripe-elements-complete-icon-color] - `icon-color` property for the element in its complete state\n * @cssprop [--stripe-elements-complete-line-height] - `line-height` property for the element in its complete state\n * @cssprop [--stripe-elements-complete-letter-spacing] - `letter-spacing` property for the element in its complete state\n * @cssprop [--stripe-elements-complete-text-decoration] - `text-decoration` property for the element in its complete state\n * @cssprop [--stripe-elements-complete-text-shadow] - `text-shadow` property for the element in its complete state\n * @cssprop [--stripe-elements-complete-text-transform] - `text-transform` property for the element in its complete state\n *\n * @cssprop [--stripe-elements-empty-color] - `color` property for the element in its empty state\n * @cssprop [--stripe-elements-empty-font-family] - `font-family` property for the element in its empty state\n * @cssprop [--stripe-elements-empty-font-size] - `font-size` property for the element in its empty state\n * @cssprop [--stripe-elements-empty-font-smoothing] - `font-smoothing` property for the element in its empty state\n * @cssprop [--stripe-elements-empty-font-variant] - `font-variant` property for the element in its empty state\n * @cssprop [--stripe-elements-empty-icon-color] - `icon-color` property for the element in its empty state\n * @cssprop [--stripe-elements-empty-line-height] - `line-height` property for the element in its empty state\n * @cssprop [--stripe-elements-empty-letter-spacing] - `letter-spacing` property for the element in its empty state\n * @cssprop [--stripe-elements-empty-text-decoration] - `text-decoration` property for the element in its empty state\n * @cssprop [--stripe-elements-empty-text-shadow] - `text-shadow` property for the element in its empty state\n * @cssprop [--stripe-elements-empty-text-transform] - `text-transform` property for the element in its empty state\n *\n * @cssprop [--stripe-elements-invalid-color] - `color` property for the element in its invalid state\n * @cssprop [--stripe-elements-invalid-font-family] - `font-family` property for the element in its invalid state\n * @cssprop [--stripe-elements-invalid-font-size] - `font-size` property for the element in its invalid state\n * @cssprop [--stripe-elements-invalid-font-smoothing] - `font-smoothing` property for the element in its invalid state\n * @cssprop [--stripe-elements-invalid-font-variant] - `font-variant` property for the element in its invalid state\n * @cssprop [--stripe-elements-invalid-icon-color] - `icon-color` property for the element in its invalid state\n * @cssprop [--stripe-elements-invalid-line-height] - `line-height` property for the element in its invalid state\n * @cssprop [--stripe-elements-invalid-letter-spacing] - `letter-spacing` property for the element in its invalid state\n * @cssprop [--stripe-elements-invalid-text-decoration] - `text-decoration` property for the element in its invalid state\n * @cssprop [--stripe-elements-invalid-text-shadow] - `text-shadow` property for the element in its invalid state\n * @cssprop [--stripe-elements-invalid-text-transform] - `text-transform` property for the element in its invalid state\n *\n * @element stripe-elements\n * @extends StripeBase\n *\n * @fires 'change' - Stripe Element change event\n */\n\nlet StripeElements = _decorate(null, function (_initialize, _LitNotify) {\n  class StripeElements extends _LitNotify {\n    constructor(...args) {\n      super(...args);\n\n      _initialize(this);\n    }\n\n  }\n\n  return {\n    F: StripeElements,\n    d: [{\n      kind: \"field\",\n      static: true,\n      key: \"is\",\n\n      value() {\n        return 'stripe-elements';\n      }\n\n    }, {\n      kind: \"field\",\n      static: true,\n      key: \"elementType\",\n\n      value() {\n        return 'card';\n      }\n\n    }, {\n      kind: \"field\",\n      static: true,\n      key: \"styles\",\n\n      value() {\n        return [sharedStyles, style];\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        attribute: 'hide-icon'\n      })],\n      key: \"hideIcon\",\n\n      value() {\n        return false;\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        attribute: 'hide-postal-code'\n      })],\n      key: \"hidePostalCode\",\n\n      value() {\n        return false;\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: String,\n        attribute: 'icon-style'\n      })],\n      key: \"iconStyle\",\n\n      value() {\n        return 'default';\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Object\n      })],\n      key: \"value\",\n\n      value() {\n        return {};\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: String,\n        notify: true,\n        readOnly: true\n      })],\n      key: \"brand\",\n\n      value() {\n        return null;\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        reflect: true,\n        notify: true,\n        readOnly: true\n      })],\n      key: \"complete\",\n\n      value() {\n        return false;\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        reflect: true,\n        notify: true,\n        readOnly: true\n      })],\n      key: \"empty\",\n\n      value() {\n        return true;\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        reflect: true,\n        notify: true,\n        readOnly: true\n      })],\n      key: \"invalid\",\n\n      value() {\n        return false;\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Object,\n        notify: true,\n        readOnly: true\n      })],\n      key: \"card\",\n\n      value() {\n        return null;\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        attribute: 'is-empty',\n        reflect: true,\n        notify: true,\n        readOnly: true\n      })],\n      key: \"isEmpty\",\n\n      value() {\n        return true;\n      }\n\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        attribute: 'is-complete',\n        reflect: true,\n        notify: true,\n        readOnly: true\n      })],\n      key: \"isComplete\",\n\n      value() {\n        return false;\n      }\n\n    }, {\n      kind: \"method\",\n      key: \"updated\",\n      value:\n      /* PUBLIC FIELDS */\n\n      /**\n       * Whether to hide icons in the Stripe form.\n       * @type {boolean}\n       */\n\n      /**\n       * Whether or not to hide the postal code field.\n       * Useful when you gather shipping info elsewhere.\n       * @type {boolean}\n       */\n\n      /**\n       * Stripe icon style. 'solid' or 'default'.\n       * @type {'solid'|'default'}\n       */\n\n      /**\n       * Prefilled values for form. Example {postalCode: '90210'}\n       * @type {object}\n       */\n\n      /* READ ONLY PROPERTIES */\n\n      /**\n       * The card brand detected by Stripe\n       * @type {string}\n       * @readonly\n       */\n\n      /**\n       * Whether the form is complete.\n       * @type {boolean}\n       * @readonly\n       */\n\n      /**\n       * If the form is empty.\n       * @type {boolean}\n       * @readonly\n       */\n\n      /**\n       * Whether the form is invalid.\n       * @type {boolean}\n       * @readonly\n       */\n      // DEPRECATED\n\n      /**\n       * The Stripe card object.\n       * **DEPRECATED**. Will be removed in a future version. use `element` instead\n       * @type {stripe.elements.Element}\n       * @readonly\n       * @deprecated\n       */\n\n      /**\n       * Whether the form is empty.\n       * **DEPRECATED**. Will be removed in a future version. use `empty` instead\n       * @type {boolean}\n       * @deprecated\n       */\n\n      /**\n       * Whether the form is complete.\n       * **DEPRECATED**. Will be removed in a future version. use `complete` instead\n       * @type {boolean}\n       * @deprecated\n       */\n      function updated(changed) {\n        _get(_getPrototypeOf(StripeElements.prototype), \"updated\", this).call(this, changed); // DEPRECATED\n\n\n        if (changed.has('element') && !this.element) this.set({\n          card: null\n        });\n      }\n      /* PUBLIC API */\n\n      /**\n       * Submit payment information to generate a paymentMethod\n       * @param {stripe.PaymentMethodData} [paymentMethodData={}]\n       * @resolves {stripe.PaymentMethodResponse}\n       */\n\n    }, {\n      kind: \"method\",\n      decorators: [stripeMethod],\n      key: \"createPaymentMethod\",\n      value: async function createPaymentMethod(paymentMethodData = this.getPaymentMethodData()) {\n        return this.stripe.createPaymentMethod(paymentMethodData);\n      }\n      /**\n       * Submit payment information to generate a source\n       * @param {{ owner: stripe.OwnerInfo }} [sourceData={}]\n       * @resolves {stripe.SourceResponse}\n       */\n\n    }, {\n      kind: \"method\",\n      decorators: [stripeMethod],\n      key: \"createSource\",\n      value: async function createSource(sourceData = this.sourceData) {\n        return this.stripe.createSource(this.element, sourceData);\n      }\n      /**\n       * Submit payment information to generate a token\n       * @param {TokenData} [tokenData=this.tokenData]\n       * @resolves {stripe.TokenResponse}\n       */\n\n    }, {\n      kind: \"method\",\n      decorators: [stripeMethod],\n      key: \"createToken\",\n      value: async function createToken(tokenData = this.tokenData) {\n        return this.stripe.createToken(this.element, tokenData);\n      }\n      /**\n       * Checks for potential validity. A potentially valid form is one that is not empty, not complete and has no error. A validated form also counts as potentially valid.\n       * @return {boolean} true if the Stripe form is potentially valid\n       */\n\n    }, {\n      kind: \"method\",\n      key: \"isPotentiallyValid\",\n      value: function isPotentiallyValid() {\n        return !this.complete && !this.empty && !this.error || this.validate();\n      }\n      /**\n       * Resets the Stripe card.\n       */\n\n    }, {\n      kind: \"method\",\n      key: \"reset\",\n      value: function reset() {\n        var _this$element;\n\n        _get(_getPrototypeOf(StripeElements.prototype), \"reset\", this).call(this);\n\n        (_this$element = this.element) === null || _this$element === void 0 ? void 0 : _this$element.clear();\n      }\n      /**\n       * Generates a payment representation of the type specified by `generate`.\n       * @resolves {PaymentResponse}\n       */\n\n    }, {\n      kind: \"method\",\n      key: \"submit\",\n      value: async function submit() {\n        switch (this.generate) {\n          case 'payment-method':\n            return this.createPaymentMethod();\n\n          case 'source':\n            return this.createSource();\n\n          case 'token':\n            return this.createToken();\n\n          default:\n            {\n              const error = this.createError(`cannot generate ${this.generate}`);\n              await this.set({\n                error\n              });\n              throw error;\n            }\n        }\n      }\n      /**\n       * Checks if the Stripe form is valid.\n       * @return {boolean} true if the Stripe form is valid\n       */\n\n    }, {\n      kind: \"method\",\n      key: \"validate\",\n      value: function validate() {\n        const {\n          complete,\n          empty,\n          error\n        } = this;\n        const isValid = !error && complete && !empty;\n        if (empty && !error) this.set({\n          error: this.createError('Your card number is empty.')\n        });\n        return isValid;\n      }\n      /* PRIVATE METHODS */\n\n      /**\n       * Generates PaymentMethodData from the element.\n       * @param  {stripe.PaymentMethodData} data data, minus card property\n       * @return {stripe.PaymentMethodData} data with card property\n       * @private\n       */\n\n    }, {\n      kind: \"method\",\n      key: \"getPaymentMethodData\",\n      value: function getPaymentMethodData() {\n        const type = 'card';\n        const {\n          billingDetails,\n          element: card,\n          paymentMethodData\n        } = this;\n        return {\n          billing_details: billingDetails,\n          ...paymentMethodData,\n          type,\n          card\n        };\n      }\n      /**\n       * Returns a Stripe-friendly style object computed from CSS custom properties\n       * @return {StripeStyleInit} Stripe Style initialization object.\n       * @private\n       */\n\n    }, {\n      kind: \"method\",\n      key: \"getStripeElementsStyles\",\n      value: function getStripeElementsStyles() {\n        const computedStyle = window.ShadyCSS ? undefined : getComputedStyle(this);\n\n        const getStyle = prop => this.getCSSCustomPropertyValue(prop, computedStyle) || undefined;\n\n        const styleReducer = ({\n          base = {},\n          complete = {},\n          empty = {},\n          invalid = {}\n        }, camelCase) => ({\n          base: { ...base,\n            [camelCase]: getStyle(`--stripe-elements-base-${dash(camelCase)}`)\n          },\n          complete: { ...complete,\n            [camelCase]: getStyle(`--stripe-elements-complete-${dash(camelCase)}`)\n          },\n          empty: { ...empty,\n            [camelCase]: getStyle(`--stripe-elements-empty-${dash(camelCase)}`)\n          },\n          invalid: { ...invalid,\n            [camelCase]: getStyle(`--stripe-elements-invalid-${dash(camelCase)}`)\n          }\n        });\n\n        return allowedStyles.reduce(styleReducer, {});\n      }\n      /**\n       * @private\n       */\n\n    }, {\n      kind: \"method\",\n      key: \"initElement\",\n      value: async function initElement() {\n        if (!this.stripe) return;\n        const {\n          hidePostalCode,\n          hideIcon,\n          iconStyle,\n          value\n        } = this;\n        const style = this.getStripeElementsStyles();\n        const options = {\n          hideIcon,\n          hidePostalCode,\n          iconStyle,\n          style,\n          value\n        };\n        const element = this.elements.create('card', options);\n        element.addEventListener('change', this.onChange);\n        await this.set({\n          element,\n          // DEPRECATED\n          card: element\n        });\n      }\n      /**\n       * Updates the element's state.\n       * @param  {stripe.elements.ElementChangeResponse}         event\n       * @param  {boolean}       event.empty     true if value is empty\n       * @param  {boolean}       event.complete  true if value is well-formed and potentially complete.\n       * @param  {string}        event.brand     brand of the card being entered e.g. 'visa' or 'amex'\n       * @param  {stripe.Error}  event.error     The current validation error, if any.\n       * @param  {String|Object} event.value     Value of the form. Only non-sensitive information e.g. postalCode is present.\n       * @private\n       */\n\n    }, {\n      kind: \"method\",\n      decorators: [bound],\n      key: \"onChange\",\n      value: async function onChange(event) {\n        const {\n          brand,\n          complete,\n          empty,\n          error = null\n        } = event;\n        const invalid = error || !empty && !complete;\n        await this.set({\n          brand,\n          complete,\n          empty,\n          error,\n          invalid,\n          // DEPRECATED\n          isComplete: complete,\n          isEmpty: empty\n        });\n        this.fire('change', event); // DEPRECATED\n\n        this.fire('stripe-change', event);\n      }\n    }]\n  };\n}, LitNotify(StripeBase));\n/** @typedef {{ base?: stripe.elements.Style, complete?: stripe.elements.Style, empty?: stripe.elements.Style, invalid?: stripe.elements.Style}} StripeStyleInit */\n\ncustomElements.define(StripeElements.is, StripeElements);\n\nexport { StripeElements };\n//# sourceMappingURL=stripe-elements.js.map\n"],"names":["stripeMethod","f","wrapped","descriptor","original","value","wrap","name","async","args","this","stripe","Error","constructor","is","handleResponse"],"mappings":"oLAaO,MAAMA,EAXb,SAAAC,UACSC,UACCC,WAAEA,GAARD,EACME,EAAWD,EAAjBE,aAEAF,EAAAA,MAAmBF,EAAnBE,GAEO,IAAAD,EAAcC,WAAAA,IAIGG,EAAK,SAAAL,SACzBM,KAAEA,GAARN,SACOO,kBAAAC,OACAC,KAALC,OAAkB,MAAM,IAAAC,MAAW,IAAGF,KAAAG,YAAiBC,kDAAkDP,aAClGN,EAAAA,KAAAA,QAAAA,GAAAA,KACCS,KADRK"}