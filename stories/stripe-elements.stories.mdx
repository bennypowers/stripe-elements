import {
  html,
  Meta,
  Preview,
  Props,
  Story,
  withKnobs, withWebComponentsKnobs
} from '@open-wc/demoing-storybook';

import '../stripe-elements.js';

import '@material/mwc-button';
import '@material/mwc-textfield';
import '@power-elements/codesandbox-button';
import '@power-elements/json-viewer';

import { $, $$, publishableKey, setKeys } from './storybook-helpers.js';

<Meta
  title="Stripe Elements"
  parameters={{
    component: 'stripe-elements',
    decorators: [withKnobs],
    options: { selectedPanel: 'storybookjs/docs/panel' }
  }}
/>

# Stripe Elements Web Component

The `<stripe-elements>` custom element is an easy way to use stripe.js in your web app.
To get started, add the element to your page with the `publishable-key` attribute set to your
[Stripe publishable key](https://dashboard.stripe.com/account/apikeys). You can also set the `publishableKey` DOM property using JavaScript

```html
<stripe-elements publishable-key="pk_test_XXXXXXXXXXXXXXXXXXXXXXXX"></stripe-elements>
```

**Careful!** never add your **secret key** to an HTML page, only publish your **publishable key**.

Once you've set the `publishable-key` attribute (or the `publishableKey` DOM property), Stripe will create a Stripe Card Element on your page.

Enter your publishable key here (use the test key, not the production key) to run the examples against your Stripe account. **Note**: This demo will store the publishable key in localstorage for your convenience.

<Story name="Enter a Stripe Publishable Key" height="80px">
  {html`
    <mwc-textfield id="publishable-key-input"
        outlined
        value="${publishableKey}"
        label="Publishable Key"
        @change="${setKeys('stripe-elements:not(#should-error)')}">
    </mwc-textfield>`
  }
</Story>

## Create a PaymentMethod

<Preview>
  <Story name="Generate a PaymentMethod" height="220px">{
    html`
      <elements-demo label="Generate PaymentMethod">
        <stripe-elements slot="stripe" generate="payment-method" publishable-key="${publishableKey}"> </stripe-elements>
      </elements-demo>
    `
  }</Story>
</Preview>

## Create a Source

<Preview>
  <Story name="Generate a Source" height="220px">{
    html`
      <elements-demo label="Generate Source">
        <stripe-elements slot="stripe" generate="source" publishable-key="${publishableKey}"> </stripe-elements>
      </elements-demo>
    `
  }</Story>
</Preview>

## Create a Token

Once you're set your publishable key and Stripe has instantiated (listen for the `stripe-ready` event if you need to know exactly when this happens),
you may generate a token from the filled-out form by calling the `createToken()` method.

<Preview>
  <Story name="Generate a Token" height="220px">{
    html`
      <elements-demo label="Generate Token">
        <stripe-elements slot="stripe" generate="token" publishable-key="${publishableKey}"> </stripe-elements>
      </elements-demo>
    `
  }</Story>
</Preview>

## Validation

`<stripe-elements>` has a `show-error` boolean attribute which will display the error message for you.
This is useful for simple validation in cases where you don't need to build your own validation UI.

<Preview>
  <Story name="Error Display" height="120px">{
    html`
      <article id="show-error">
        <stripe-elements publishable-key="should-error-use-bad-key" show-error> </stripe-elements>
        <mwc-button outlined @click="${event => event.target.parentElement.querySelector('stripe-elements').validate()}">Validate</mwc-button>
      </article>
    `
  }</Story>
</Preview>

## Advanced Validation

`<stripe-elements>` comes with several properties, events, and methods for validation.
Listen for the `is-complete-changed`, `is-empty-changed`, and `has-error-changed` events
and check the `isComplete`, `isEmpty`, and `hasError` properties to react to validation changes.
These properties to their dash-cased attributes,
so you can use CSS to style your element in its various states.

```css
.StripeElement {
  border: none;
  box-shadow: none;
}

stripe-elements {
  border-radius: 4px;
  border: 2px solid transparent;
}

stripe-elements[is-complete] { border-color: rebeccapurple; }
stripe-elements[has-error] { border-color: salmon; }
```

<Preview>
  <Story name="Validation States" height="120px">{
    html`
      <style>
      #states .StripeElement { border: none; box-shadow: none; }
      #states stripe-elements { border-radius: 4px; border: 2px solid transparent; }
      #states stripe-elements[is-complete] { border-color: rebeccapurple; }
      #states stripe-elements[has-error] { border-color: salmon; }
      </style>
      <article id="states">
        <stripe-elements publishable-key="${publishableKey}"> </stripe-elements>
        <mwc-button outlined @click="${event => event.target.parentElement.querySelector('stripe-elements').validate()}"> Validate</mwc-button>
      </article>
    `
  }</Story>
</Preview>

For more complex needs, you can listen for the `stripe-error` event.

## Automatically Posting the Payment Info

For simple integrations, you can automatically post the source or token to your backend by setting the `action` property

**NOTE**: For this demo, we've overridden `window.fetch` to return a mocked response with the text body "A-OK!".

<Preview>
  <Story name="Automatically Posting the Payment Info">
  {() => {
    const originalFetch = window.fetch;
    window.fetch = (url, ...args) => url === '/my-endpoint' ? Promise.resolve(new Response('A-OK!')) : originalFetch(url, ...args);
    const onClick = (event) => event.target.parentElement.querySelector('stripe-elements').submit();
    const display = x => $('#auto-post output').textContent = x;
    const onSuccess = ({ detail }) => detail.text().then(display);
    return html`
      <article id="auto-post">
        <stripe-elements
            publishable-key="${publishableKey}"
            generate="token"
            action="/my-endpoint"
            @success="${onSuccess}"
        > </stripe-elements>
        <mwc-button class="generate" outlined @click="${onClick}">Submit and POST</mwc-button>
        <output> </output>
      </article>
    `
  }}</Story>
</Preview>

# Using `<stripe-elements>` Across Frameworks

Since `<stripe-elements>` is a custom-element, you can easily use it across frameworks.

<Story name="In Plain HTML and JavaScript"> </Story>

## Using with Plain HTML and JavaScript

<codesandbox-button sandbox-id="y4h9n"> </codesandbox-button>

```html
<script type="module" src="https://unpkg.com/@power-elements/stripe-elements?module"></script>
<script type="module" src="https://unpkg.com/@power-elements/json-viewer?module"></script>
<script type="module" src="https://unpkg.com/@material/mwc-button?module"></script>

<stripe-elements publishable-key="pk_test_XXXXXXXXXXXXXXXXXXXXXXXX"></stripe-elements>

<mwc-button disabled>Submit</mwc-button>

<json-viewer></json-viewer>

<script>
  const viewer = document.querySelector("json-viewer");
  const stripe = document.querySelector("stripe-elements");
  const submit = document.querySelector("mwc-button");

  submit.addEventListener("click", onClickSubmit);
  stripe.addEventListener("stripe-source", onStripeSource);
  stripe.addEventListener("stripe-change", onChange);

  function onClickSubmit() {
    stripe.createSource();
  }

  function onChange({ target }) {
    submit.disabled = !target.validate();
  }

  function onStripeSource({ target: { source } }) {
    const handleAsJson = response => response.json();
    const viewJson = object => (viewer.object = object);

    const method = "POST";
    const body = JSON.stringify(source);
    const headers = { "Content-Type": "application/json" };

    fetch("/payments", { method, body, headers })
      .then(handleAsJson)
      .then(viewJson)
      .catch(viewJson);
  }
</script>
```

## In a `LitElement`

<Story name="In a LitElement">
 {html`<codesandbox-button sandbox-id="8m7uk"></codesandbox-button>`}
</Story>

```js
import '@power-elements/stripe-elements';
import '@power-elements/json-viewer';
import { LitElement, html } from 'lit-element';
import { PUBLISHABLE_KEY } from './config.js';

class PaymentForm extends LitElement {
  render() {
    return html`
      <mwc-button ?disabled="${this.submitDisabled}" @click="${this.onClick}">
        Submit
      </mwc-button>

      <stripe-elements
          publishable-key="${PUBLISHABLE_KEY}"
          @change="${this.onChange}"
          @source="${this.onSource}"
      ></stripe-elements>

      <json-viewer .object="${ifDefined(this.source)}"></json-viewer>
    `;
  }

  onChange({ target: { isComplete, hasError } }) {
    this.submitDisabled = !(isComplete && !hasError);
  }

  onClick() {
    this.shadowRoot.querySelector("stripe-elements").createSource();
  }

  onSource({ detail: source }) {
    this.source = source;
  }
}
```

<Story name="In a Polymer Element"> </Story>

### In a Vue Component

<Story name="In a Vue Component">
  {html`<codesandbox-button sandbox-id="06ulb" module="/src/Payment.vue"> </codesandbox-button>`}
</Story>


```html
<template>
  <article>
    <stripe-elements
      ref="stripe"
      @change="onChange"
      @token="onToken"
      @error="onError"
      :publishable-key="publishableKey"
    ></stripe-elements>

    <mwc-button :disabled="!isComplete || isEmpty" @click="onClick">Get Token</mwc-button>

    <json-viewer v-if="error || token" :object.prop="error || token"></json-viewer>
  </article>
</template>

<script>
import { PUBLISHABLE_KEY } from './config';

export default {
  name: "payment-form",
  data() {
    return {
      publishableKey: PUBLISHABLE_KEY,
      token: null,
      error: null,
      isComplete: false,
      isEmpty: true
    };
  },
  methods: {
    onChange({ target: { isComplete, isEmpty } }) {
      this.isComplete = isComplete;
      this.isEmpty = isEmpty;
    },

    onClick() {
      this.$refs.stripe.createToken();
    },

    onToken({ detail: token }) {
      this.token = token;
    },

    onError({ detail: error }) {
      this.error = error;
    },
  }
};
</script>
```

### In an Angular Component

<Story name="In an Angular Component">
  {html`<codesandbox-button sandbox-id="0mgh4" module="/src/app/app.component.ts"> </codesandbox-button>`}
</Story>


```ts
import { Component } from "@angular/core";
import { PUBLISHABLE_KEY } from './config';

const template = `
  <stripe-elements
    #stripe
    (change)="disabled = !$event.target.isComplete"
    (token)="token = $event.detail"
    (error)="error = $event.detail"
    [publishableKey]="publishableKey"
  ></stripe-elements>

  <mwc-button [disabled]="disabled" (click)="createToken(stripe)">Get Token</mwc-button>

  <json-viewer *ngIf="token" [object]="token"></json-viewer>
  <json-viewer *ngIf="error" [object]="error"></json-viewer>
`;

const styleUrls = ["./app.component.css"];

@Component({ selector: "app-root", template, styleUrls })
export class AppComponent {
  publishableKey: string = PUBLISHABLE_KEY;
  disabled = true;
  token?: stripe.Token = null;
  error?: Error | stripe.Error = null;
  createToken(stripeElements: any) {
    stripeElements.createToken();
  }
}
```

### In a React Component

<Story name="In a React Component">
  {html`<codesandbox-button sandbox-id="23zw8"> </codesandbox-button>`}
</Story>


```jsx
import React, { useState, useRef, useEffect } from "react";
import ReactDOM from "react-dom";
import { getPropOr, compose } from "crocks";
import { PUBLISHABLE_KEY } from './config';
import "./styles.css";

const isDisabled = ({ isComplete, isEmpty }) => !isComplete || isEmpty;
const getTarget = getPropOr({}, "target");
const getDetail = getPropOr(null, "detail");
const getToken = getPropOr(null, "token");

function App() {
  const stripeRef = useRef(null);
  const viewerRef = useRef(null);
  const inputRef = useRef(null);
  const buttonRef = useRef(null);
  const [disabled, setDisabled] = useState(true);
  const [token, setToken] = useState(null);
  const [error, setError] = useState(null);

  const onChange = compose(setDisabled, isDisabled, getTarget);
  const onError = compose(setError, getDetail);
  const onToken = compose(setToken, getToken);

  const onClick = async () =>
    stripeRef.current.createToken()
      .then(getToken);
      .then(setToken);

  useEffect(() => {
    stripeRef.current.addEventListener("change", onChange);
    stripeRef.current.addEventListener("error", onError);
    stripeRef.current.addEventListener("token", onToken);
    buttonRef.current.addEventListener("click", onClick);
    buttonRef.current.disabled = disabled;
    if (token || error) viewerRef.current.object = token;
  });

  return (
    <article className="App">
      <stripe-elements ref={stripeRef} publishable-key={PUBLISHABLE_KEY} />
      <mwc-button ref={buttonRef}>Submit</mwc-button>
      <json-viewer ref={viewerRef} />
    </article>
  );
}

ReactDOM.render(<App />, document.getElementById("root"));
```

### In a Preact Component

<Story name="In a Preact Component">
  {html`<codesandbox-button sandbox-id="mqskb"> </codesandbox-button>`}
</Story>

```jsx
import { loadScripts } from "./loadScripts";
import { render } from "preact";
import { useState, useRef } from "preact/hooks";
import { getPropOr, compose } from "crocks";
import { PUBLISHABLE_KEY } from './config';
import "./style";

const isDisabled = ({ isComplete, isEmpty }) => !isComplete || isEmpty;
const getTarget = getPropOr({}, "target");
const getDetail = getPropOr(null, "detail");
const getToken = getPropOr(null, "token");

export default function App() {
  const stripeRef = useRef(null);
  const [disabled, setDisabled] = useState(true);
  const [token, setToken] = useState(null);
  const [error, setError] = useState(null);

  const onChange = compose(setDisabled, isDisabled, getTarget);
  const onError = compose(setError, getDetail);
  const onToken = compose(setToken, getToken);

  const onClick = async () =>
    stripeRef.current.createToken()
      .then(getToken)
      .then(setToken);

  return (
    <article className="App">
      <stripe-elements
        ref={stripeRef}
        onchange={onChange}
        onerror={onError}
        ontoken={onToken}
        publishable-key={publishableKey}
      />
      <mwc-button onClick={onClick} disabled={disabled}>Submit</mwc-button>
      {(error || token) && <json-viewer object={error || token} />}
    </article>
  );
}

if (typeof window !== "undefined") {
  render(<App />, document.getElementById("root"));
}
```

## API

<Props of="stripe-elements" />
